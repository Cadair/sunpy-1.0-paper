\section{Affiliated Packages - Steven}
\label{sec:affil_package}
In order to foster an interoperable software environment which minimizes the cognitive burden on users, the \sunpy project supports the concept of affiliated packages.
A \sunpy affiliated package is a \python package that builds upon the functionality of the \sunppkg package or provides general functionality useful to solar data analysis. Affiliated packages can also be used to develop and mature core functionality outside of the constraints of \sunppkg.

In order to promote high-quality code and foster consistency and interoperability the following requirements must be satisfied by any potential affiliated packages.
\begin{itemize}
    \item In order to reduce code duplication and complexity, the package must make use of all appropriate features in \sunppkg.
    \item Documentation must be provided that explains the function and use of the package, and it should be of comparable quality to \sunppkg.
    \item A test suite must be provided to verify the correct operation of the package.
    \item The developers should engage with the community to encourage knowledge and code sharing.
\end{itemize}

Developers can formally apply to become an affiliated package to the \sunpy lead developer whose responsibilities include to define the application and review process. Final approval is required of the board for acceptance. Packages are re-reviewed on a yearly basis to ensure that they continue to meet the standards. All affiliated packages are listed on \url{sunpy.org}, provided support by the \sunpy developer community, and further advertised at conferences and workshops. In addition, the project further defines sponsored affiliated package which is an affiliated package whose maintenance and development is the responsibility of the \sunpy project.  

The following section provides short descriptions of the existing affiliated packages.
\label{sec:affil_packages}

\subsection{drms - Kolja Glogowski - MONICA}
\label{sec:drms}

The \package{drms} affiliated package provides functionality which allows for direct access to data hosted by the Joint Science Operations Center (JSOC). This is the primary data center for the Solar Dynamics Observatoryâ€™s (SDO)\todo{check if these instruments have already been reference before this section, and make sure that reference are provided} Helioseismic and Magnetic Imager (HMI) and Atmospheric Imaging Assembly (AIA) instruments as well as data from the Solar and Heliospheric Observatory's (SoHO) Michelson Doppler Imager (MDI) instrument. DRMS stands for Data Record Management System, a pSQL database that contains metadata, as well as pointers to image data, for every image taken by AIA, HMI, and MDI. The \package{drms} package provides access to the unique search capabilities of the JSOC which include: metadata search queries, export tailored FITS files and serve these files in a variety of methods, as well as export data as movies and images in various formats.

\todo{schriste - clean up, add more detail on that last sentence, also say what is the JSOC API interface}.

\subsection{ndcube - Dan Ryan}
\package{ndcube} is a free, open-source, community-developed Python package for manipulating N-dimensional coordinate-aware astronomical data.
The package provides a unified API for slicing, visualization, coordinate conversion and inspection of the data, metadata and coordinate transformations.
\texttt{ndcube}'s data classes are not specific to any number or physical type of axis.
It can therefore be used for any data type (e.g. images, spectra, timeseries, etc.) so long as it can represented by an array and a set of World Coordinate System (WCS) transformations.
This makes \texttt{ndcube}'s data classes ideal for subclassing when creating data-type-specific classes while keeping the non-data-type-specific functionalities (e.g. slicing) common between classes.

The \texttt{ndcube} package is composed of two basic data classes, \texttt{NDCube} and \texttt{NDCubeSequence}.
(Note the \texttt{ndcube} package is distinguished from the \texttt{NDCube} data class via capitalization.)
\texttt{NDCube} is for managing a single array and set of WCS transformations, while \texttt{NDCubeSequence} is for handling multiple arrays, each described by their own set of WCS transformations.
They share similar APIs to enable the user to think about their data in an intuitive way, rather than focusing on the format in which that data happens to be stored.

\texttt{NDCube} is subclassed from \texttt{astropy}'s \texttt{NDDdata} class and so provides attributes for a single data array (\texttt{NDCube.data}) and corresponding uncertainty (\texttt{NDCube.uncertainty}) and mask arrays (\texttt{NDCube.mask}).
It also provides attributes for the data unit (\texttt{NDCube.unit}) and metadata (\texttt{NDCube.meta}).
Transformations between the pixel/array indices and real world coordinates can be stored in two ways.
The first is as an \texttt{astropy.wcs.WCS} instance in the \texttt{NDCube.wcs} attribute.
Currently a \texttt{WCS} instance is required.
The WCS framework is standard throughout astronomy and many powerful tools for plotting and performing transformations exist in the \texttt{astropy} which are leveraged by \texttt{ndcube}.
New coordinate transformation tools like \texttt{astropy}'s \texttt{gWCS} (Generalized World Coordinate System) will be incorporated into \texttt{ndcube} in the future.
A second optional method of storing coordinate information is as a dictionary of extra coordinates in the \texttt{NDCube.extra\_coords} attribute.
Each entry stores the coordinate's name, the axis or axes to which it corresponds, and a \texttt{numpy.array} or an \texttt{astropy.unit.Quantity} giving the coordinate value at each location along the relevant axis/axes.
The final attribute is \texttt{NDCube.missing\_axis} which will be discussed below.

One of \texttt{NDCube}'s most useful capabilities is its simple, yet powerful slicing.
Slicing can be performed in array-index-space or using real world coordinates.
\texttt{NDCube} uses Python's native slicing API to crop in array-index-space as can be done for other objects like list, tuples, numpy arrays, astropy Quantities, etc.
However, in the case of \texttt{NDCube}, the slicing in not only applied to data array, but also the uncertainty, mask, WCS transformations and extra coordinates.
This allows users to move closer to the speed of thought during their analysis by freeing them from the tedious, well-understood, but easy-to-mishandle process of slicing all aspects of their data.

It is also possible to crop an \texttt{NDCube} instance using real world coordinates thanks to its \texttt{NDCube.crop\_by\_coords} method.
A user defines the lower and upper bounds of a region of interest along each axis using the real world coordinates of the \texttt{WCS} instance.
The method then determines the smallest rectangular region in array-index-space which encompasses that region of interest.
In addition to \texttt{NDCube.crop\_by\_coords}, there is an analogous \texttt{NDCube.crop\_by\_extra\_coord} method which allows a user to crop an \texttt{NDCube} instance using a single extra coordinate.
As with the array-index-space slicing described above, both the above methods apply the cropping not only to the data, but also the uncertainty, mask, \texttt{WCS} instance and extra coordinates.

When slicing data it is common to reduce the dimensionality of the data when only interested in one point along one of the axes.
This can cause issues if the coordinate transformation of another axis is dependent on information from the reduced axis, e.g.\ latitude and longitude.
For this reason, axes from the WCS instance are never removed, only reduced to a length of 1.
However, the dimensionality of the data, uncertainty and mask are reduced in the normal way.  
This can lead to scenarios where there are more axes in the \texttt{WCS} instance than the data arrays.
To handle this issue, the \texttt{NDCube.missing\_axis} attribute is used.
This is a list boolean values which indicate which axes of the \texttt{WCS} instance do not have a corresponding axis in the data array.  
By referencing \texttt{NDCube.missing\_axis}, the correct WCS transformations can always be made.
In the case of extra coordinates corresponding to a reduced axis, the coordinate value at the location where the axis was sliced is retained, but the extra coordinate's axis is presented as \texttt{None}.

While \texttt{NDCube.extra\_coords} explicitly supplies the value of a coordinate at each location along its associated axis or axes, such values for the coordinates of the \texttt{WCS} instance are stored functionally.
Although this can be very useful, e.g.\ by reducing the size of the object and enabling the use of powerful plotting tools like \texttt{WCSAxes}, there are times when a user wants to extract the coordinate values.
\texttt{NDCube} provides a few methods to conveniently perform these transformations.
\texttt{NDCube.pixel\_to\_world} allows a user to get the real world coordinates of a pixel or multiple pixels by entering their indices along all axes.  \texttt{NDCube.world\_to\_pixel} does the same in reverse.  As with the equivalent native \texttt{astropy.wcs.WCS} method, \texttt{world\_to\_pixel} returns the non-integer index values that precisely correspond to the input real world coordinates.  These methods are very useful in performing the transformations for a few array indices, but can be cumbersome when a user wants to perform the transformations for many or all pixels.  To make this easier, \texttt{NDCube} has a \texttt{axis\_world\_coords} method which returns the real world coordinates at each index along all axes.
The only input required is the name or number of the axis or axes along which the transformations should be performed.  The default is to do this for all axes.

\texttt{NDCube} has a number a helpful inspection properties help the user quickly understand the data within.  The \texttt{NDCube.dimensions} which returns an \texttt{astropy.units.Quantity} instance with the length of each data axis.
The \texttt{NDCube.world\_physical\_axis\_types} gives the physical type of each axis derived on the \texttt{CTYPE} parameters on the \texttt{WCS} instance.  By default the names are complaint with the IVOA UCD1+ controlled vocabulary\footnote{\url{http://www.ivoa.net/documents/REC/UCD/UCDlist-20070402.html}} but can be overridden when subclassing.

Another very helpful capability of \texttt{NDCube} is its built-in visualization suite.  It provides a simple, generic API via the \texttt{NDCube.plot} method which visualizes the data differently depending on user inputs and the number of dimensions.  Either a static line plot or image can be produced for 1- and 2-D data cubes, while animated line plots and images can be produced for data cube of $>$1 dimension.  Users can pick which axis or axes should make up the plot/image axes while other dimensions are animated through using interactive sliders.  This visualization suite is based on sunpy animator classes and is the only part of \texttt{NDCube} that is dependent on sunpy itself.  However, the suite is provided as a mixin class so users who don't want to depend of sunpy or who want to build more specific or powerful visualization suites can do so easily by combining their own mixin with \texttt{NDCube}'s other powerful capabilities.

Many of \texttt{NDCube}'s capabilities, such as its slicing and coordinate transformations, depends on the existence a single data array described by a single set of WCS transformations.
However a single set of WCS transformations may not always adequately describe our data set.
Handling these cases is the role of \texttt{NDCubeSequence}, \texttt{ndcube}'s second main data class.
Fundamentally \texttt{NDCubeSequence} is a list of \texttt{NDCube} instances with the same slicing and visualization APIs as \texttt{NDCube} which enable users to still think of and interact with their data as if were a single cube.
By default, \texttt{NDCubeSequence} effectively adds an extra dimension to the data which is considered perpendicular to the axes of the constituent \texttt{NDCube}s.
For example, say we have a set of images, each described its own set of WCS transformations.
Fine pointing adjustments have been applied to each frame manually which introduce discontinuities between the WCS transformations through time.
Therefore, the data cannot by represented by a single combined set of WCS transformations and hence can't be stored in an \texttt{NDCube}.
However, it can be represented as an \texttt{NDCubeSequence} of 2-D \texttt{NDCube}s where the time axis is now represented by the sequence axis.
The data set will be represented as 3-D and users can still, slice, visualize, and perform coordinate transformations in almost the same way as if the data were still stored in a single data cube.

\texttt{NDCubeSequence} can also handle more complicated versions of this scenario.
Say our set of images do not require fine-scale pointing adjustments, but rather are interrupted by a single pointing manoeuvre.  This means that the data set can be described by two sequential 3-D image cubes, the first with a set of WCS transformations before the pointing manoeuvre and second with one from after.
We would still prefer to think of our data as a single 3-D cube but unlike the above example, the sequence axis is not a truly independent dimension, but rather parallel to the time axes of the constituent \texttt{NDCube}s.
In other words, moving from cube to cube along the sequence dimension is the same moving along the time axis, just in bigger steps, than if we were to move along the time axis within a sub-cube.
\texttt{NDCubeSequence} makes this easy by enabling the user to set the \texttt{common\_axis} attribute to one of the data axes of the constituent \texttt{NDCube}s.
With the \texttt{common\_axis} set, users can choose to slice, visualize and inspect the \texttt{NDCubeSequence} as either a 4-D or 3-D data set thanks to properties and methods such as \texttt{NDCubeSequence.index\_as\_cube} and \texttt{NDCubeSequence.plot\_as\_cube}.


\subsection{radiospectra - David}


\subsection{IRISPy - Dan Ryan}
\package{IRISPy} is a package that provides tools to read, manipulate and visualize data from the Interface Region Imaging Spectrograph (IRIS; \citealt{DePontieu2014}). It provides a set of classes for handling both the slit-jaw imager (SJI) and spectrograph (SG) observations. These link the observations with various forms of supporting data including: measurement uncertainties; units; a data mask to mark pixels with unreliable or unphysical data values; WCS (World Coordinate System) transformations that describe the position, wavelengths and times represented by the pixels; and general metadata. These classes also provide methods for applying a number of calibration routines including exposure time correction and conversion between data number, photons, and energy units. 

%Moreover, because the data unit is linked to the object, it is always obvious what unit the data is in. This saves scientists the hassle of performing important, but laborious and repetitive data conversions and avoid confusion by always tracking the unit of the data through those conversions. This leads to more efficient and accurate science.